local _docker_registry_name = std.extVar("docker.registry.name");
local _docker_registry_repository = std.extVar("docker.registry.repository");
local _docker_restart_policy = std.extVar("docker.restart_policy");
local _docker_user_uid = std.extVar("docker.user.uid");
local _docker_user_gid = std.extVar("docker.user.gid");
local _docker_user_name_to_uid = std.extVar("docker.user.name_to_uid");
local _docker_user_group_to_gid = std.extVar("docker.user.group_to_gid");
local _docker_path_mapping = std.extVar("docker.path_mapping");
local _docker_debug_host = std.extVar("docker.debug.host");
local _docker_debug_disabled = std.extVar("docker.debug.disabled");
local _docker_cache_from_image = std.extVar("docker.cache_from_image");
local _docker_build_image_tag = std.extVar("docker.build_image_tag");
local _docker_directory = std.extVar("docker.directory");
local _docker_compose_file_version = std.extVar("docker.compose.file_version");
local _docker_compose_service_init = std.extVar("docker.compose.service_init");
local _docker_compose_service_context_root = std.extVar("docker.compose.service_context_root");
local _docker_jsonnet_virtualhost_disabled = std.extVar("docker.jsonnet.virtualhost_disabled");
local _docker_jsonnet_binary_disabled = std.extVar("docker.jsonnet.binary_disabled");
local _docker_reverse_proxy_type = std.extVar("docker.reverse_proxy.type");
local _docker_reverse_proxy_network_id = std.extVar("docker.reverse_proxy.network_id");
local _docker_reverse_proxy_network_names = std.extVar("docker.reverse_proxy.network_names");
local _docker_reverse_proxy_certresolver = std.extVar("docker.reverse_proxy.certresolver");
local _docker_reverse_proxy_https = std.extVar("docker.reverse_proxy.https");
local _docker_reverse_proxy_redirect_to_https = std.extVar("docker.reverse_proxy.redirect_to_https");
local _docker_reverse_proxy_redirect_to_path_prefix = std.extVar("docker.reverse_proxy.redirect_to_path_prefix");
local _docker_disabled_services = std.extVar("docker.disabled_services");
local _docker_port_prefix = std.extVar("docker.port_prefix");
local _core_project_name = std.extVar("core.project.name");
local _core_os = std.extVar("core.os");
local _core_env_current = std.extVar("core.env.current");
local _core_env_available = std.extVar("core.env.available");
local _core_path_project_home = std.extVar("core.path.project_home");
local _core_path_ddb_home = std.extVar("core.path.ddb_home");
local _core_path_home = std.extVar("core.path.home");

# local sep = if _core_os == "nt" then std.char(92) else "/"; # Backslash can't be escaped properly, so use std.char

/**
 * Join objects from an array
 */
local JoinObjectArray(object_array) =
    local join(array, index, result) =
        if index >= std.length(array) then
            result
        else
            join(array, index + 1, result + array[index]);
    join(object_array, 0, {});

local mapPath(path) =
  local key = std.filter(function(mapping_field) std.startsWith(path, mapping_field), std.objectFields(_docker_path_mapping));
  if std.length(key) > 0 then _docker_path_mapping[key[0]] + std.substr(path, std.length(_docker_path_mapping[key[0]]), std.length(path)) else path;

local path = {
    map: mapPath,
    project: mapPath(_core_path_project_home),
    project_home: mapPath(_core_path_project_home),
    ddb_home: mapPath(_core_path_ddb_home),
    home: mapPath(_core_path_home)
};

local Service(restart_policy=_docker_restart_policy) = {
    [ if _docker_compose_service_init then "init"]: true,
    "restart": restart_policy,
};

local Image(image=null) = Service() + {
    [if image != null then "image"]: image
};

local image_uri(image_name, with_tag = true) =
    local image_uri = std.join('/', std.filter(function(s) s != null, [_docker_registry_name, _docker_registry_repository, image_name]));
    if (with_tag == true && _docker_build_image_tag != null) then image_uri + ':' + _docker_build_image_tag else image_uri;

local Expose(container_port, host_port_suffix = null, protocol = null) =
    local container_port_str = std.toString(container_port);
    local host_port_suffix_str = if host_port_suffix == null then null else std.toString(host_port_suffix);
    local effective_host_port_suffix = if host_port_suffix_str == null then std.substr(container_port_str, std.length(container_port_str) - 2, 2) else host_port_suffix_str;
    local effective_protocol = if protocol == null then "" else "/" + protocol;
    {
        ports+: [
            _docker_port_prefix + effective_host_port_suffix + ":" + container_port + effective_protocol
        ]
    };

local Build(name, image=name, cache_from_image=_docker_cache_from_image, directory=_docker_directory) = Service() + {
    "build": {
        [if (cache_from_image && (_docker_registry_name != null || _docker_registry_repository != null) != null) then "cache_from"]: [
            image_uri(image)
        ]
    }
    +
    (if _docker_compose_service_context_root then {
        "context": ".",
        "dockerfile": std.join("/", [directory, image, "Dockerfile"])
    } else {"context": std.join("/", [directory, image])}),
    [if (image != null && (_docker_registry_name != null || _docker_registry_repository != null)) then "image"]: image_uri(image)
};

local User(uid=_docker_user_uid, gid=_docker_user_gid) = {
    "user": uid + ":" + gid
};

local userNameToUid(name) =
    _docker_user_name_to_uid[name];

local groupNameToGid(group) =
    _docker_user_group_to_gid[group];

local volume_is_named(v) =
    !std.setMember("/", v) && !std.setMember(std.char(92), v) && v != ".";

local volume_source(v) =
    if std.type(v) == 'object' then
        mapPath(v.source)
    else
        local splitted = std.split(mapPath(v), ":");
        local last = if std.length(splitted) >= 1 then splitted[std.length(splitted) - 1];
        if (last == 'rw' || last == 'ro') then
            std.join(":", splitted[:std.length(splitted) - 2])
        else
            std.join(":", splitted[:std.length(splitted) - 1]);

local apply_disabled_services(compose) =
    if std.objectHas(compose, 'services') then
      local services = {
          [key]: compose.services[key] for key in std.objectFields(compose.services) if std.count(_docker_disabled_services, key) <= 0
      };

      compose { services: services }
    else
      compose;

local ServiceName(name=null) = std.join("-", std.prune([_core_project_name, name]));

local Volumes(services) = {
        [key]: {} for key in
        std.set(
            std.filter(volume_is_named,
                std.map(volume_source,
                    std.flatMap(function (f) if std.objectHas(services[f], "volumes") then services[f].volumes else [],
                        std.objectFields(services)
                    )
                )
            )
        )
};

local NoBinaryOptionsLabels(name, options, options_condition = null, index = null) = {};
local BinaryOptionsLabels(name, options, options_condition = null, index = null) = {
    ["ddb.emit.docker:binary[" + name + "](options)" + (if index != null then "(c" + index + ")" else "")]: options,
    [if options_condition != null then "ddb.emit.docker:binary[" + name + "](options_condition)" + (if index != null then "(c" + index + ")" else "")]: options_condition
};

local NoBinaryOptions(name, options, options_condition = null, index = null) = {};
local BinaryOptions(name, options, options_condition = null, index = null) = {
    labels +: BinaryOptionsLabels(name, options, options_condition, index),
};

local NoBinaryLabels(name, workdir = null, args = null, options = null, options_condition = null, exe = null, condition = null) = {};
local BinaryLabels(name, workdir = null, args = null, options = null, options_condition = null, exe = null, condition = null) = {
    ["ddb.emit.docker:binary[" + name + "](name)"]: name,
    [if workdir != null then "ddb.emit.docker:binary[" + name + "](workdir)"]: workdir,
    [if args != null then "ddb.emit.docker:binary[" + name + "](args)"]: args,
    [if options != null then "ddb.emit.docker:binary[" + name + "](options)"]: options,
    [if options_condition != null then "ddb.emit.docker:binary[" + name + "](options_condition)"]: options_condition,
    [if exe != null then "ddb.emit.docker:binary[" + name + "](exe)"]: exe,
    [if condition != null then "ddb.emit.docker:binary[" + name + "](condition)"]: condition
};

local NoBinary(name, workdir = null, args = null, options = null, options_condition = null, exe = null, condition=null) = {};
local Binary(name, workdir = null, args = null, options = null, options_condition = null, exe = null, condition=null) = {
    labels +: BinaryLabels(name, workdir, args, options, options_condition, exe, condition),
};

local Networks(services, network_names=_docker_reverse_proxy_network_names) = {
        [key]: {
            "external": true,
            "name": if std.objectHas(network_names, key) then network_names[key] else key
        } for key in
        std.uniq(
            std.filter(function (n) n != "default",
                std.flatMap(function (f) if std.objectHas(services[f], "networks") then services[f].networks else [],
                    std.objectFields(services)
                )
            )
        )
};

local Compose(config={}, network_names=_docker_reverse_proxy_network_names, version=null) =
    local effective_version = if version != null then version else _docker_compose_file_version;
    apply_disabled_services(config) + {
        "version": effective_version,
        "networks": Networks(self.services, network_names),
        "volumes": Volumes(self.services)
    };

local NoTraefikCertLabels(hostname, service_name, certresolver=null) = {};
local TraefikCertLabels(hostname, service_name, certresolver=null) = {
    [if certresolver != null then "traefik.http.routers." + service_name + "-tls.tls.certresolver"]: certresolver,
    [if (certresolver == null && _docker_reverse_proxy_certresolver != null) then "traefik.http.routers." + service_name + "-tls.tls.certresolver"]: _docker_reverse_proxy_certresolver,
    [if (certresolver == null && _docker_reverse_proxy_certresolver == null) then "ddb.emit.certs:generate[" + service_name + "]"]: hostname,
};

local TraefikRoutersRuleLabels(hostname, service_name, router_rule=null, https=null) =
    local effective_https = if https != null then https else _docker_reverse_proxy_https;
{
    [if router_rule == null then "traefik.http.routers." + service_name + ".rule"]: "Host(`" + hostname + "`)",
    [if router_rule == null && effective_https == true then "traefik.http.routers." + service_name + "-tls.rule"]: "Host(`" + hostname + "`)",
    [if router_rule != null then "traefik.http.routers." + service_name + ".rule"]: router_rule,
    [if router_rule != null && effective_https == true then "traefik.http.routers." + service_name + "-tls.rule"]: router_rule,
};

local TraefikPathPrefixLabels(hostname, service_name, path_prefix=null, https=null) =
    local effective_https = if https != null then https else _docker_reverse_proxy_https;
    local effective_rule = "Host(`" + hostname + "`) && PathPrefix(`" + path_prefix + "{regex:$$|/.*}`)";
    {
        [if path_prefix != null then "traefik.http.middlewares." + service_name + "-stripprefix.stripPrefix.prefixes"]: path_prefix,
        [if path_prefix != null then "traefik.http.routers." + service_name + ".rule"]: effective_rule,
        [if path_prefix != null && effective_https == true then "traefik.http.routers." + service_name + "-tls.rule"]: effective_rule,
        [if path_prefix != null then "traefik.http.routers." + service_name + ".middlewares"]: service_name + "-stripprefix",
        [if path_prefix != null && effective_https == true then "traefik.http.routers." + service_name + "-tls.middlewares"]: service_name + "-stripprefix",
    };

local TraefikPathPrefixRedirectLabels(hostname, service_name, path_prefix=null, redirect_to_path_prefix=null, https=null) =
    local effective_https = if https != null then https else _docker_reverse_proxy_https;
    local effective_redirect_to_path_prefix = if redirect_to_path_prefix != null then redirect_to_path_prefix else _docker_reverse_proxy_redirect_to_path_prefix;
    local effective_rule = "Host(`" + hostname + "`)";
    {
        [if path_prefix != null && effective_redirect_to_path_prefix != null then "traefik.http.middlewares." + service_name + "-redirect_to_path_prefix.redirectregex.regex"]: '^https?://' + hostname + '/?$$',
        [if path_prefix != null && effective_redirect_to_path_prefix != null then "traefik.http.middlewares." + service_name + "-redirect_to_path_prefix.redirectregex.replacement"]: path_prefix,
        [if path_prefix != null && effective_redirect_to_path_prefix != null then "traefik.http.routers." + service_name + "-redirect_to_path_prefix.rule"]: effective_rule,
        [if path_prefix != null && effective_redirect_to_path_prefix != null && effective_https == true then "traefik.http.routers." + service_name + "-redirect_to_path_prefix-tls.rule"]: effective_rule,
        [if path_prefix != null && effective_redirect_to_path_prefix != null then "traefik.http.routers." + service_name + "-redirect_to_path_prefix.middlewares"]: service_name + "-redirect_to_path_prefix",
        [if path_prefix != null && effective_redirect_to_path_prefix != null && effective_https == true then "traefik.http.routers." + service_name + "-redirect_to_path_prefix-tls.middlewares"]: service_name + "-redirect_to_path_prefix",
        [if path_prefix != null && effective_redirect_to_path_prefix != null && effective_https == true then "traefik.http.routers." + service_name + "-redirect_to_path_prefix-tls.tls"]: "true",
    };

local TraefikRedirectToHttpsLabels(hostname, service_name, redirect_to_https=null) =
    local effective_redirect_to_https = if redirect_to_https != null then redirect_to_https else _docker_reverse_proxy_redirect_to_https;
    {
      [if effective_redirect_to_https == true then "traefik.http.routers." + service_name + ".middlewares"]: service_name + "-redirect-to-https",
      [if effective_redirect_to_https == true then "traefik.http.middlewares." + service_name + "-redirect-to-https.redirectscheme.scheme"]: "https",
    };

local NoTraefikLabels(port, hostname, name=null, certresolver=null, router_rule=null, redirect_to_https=null, https=null, path_prefix=null, redirect_to_path_prefix=null) = {};
local TraefikLabels(port, hostname, name=null, certresolver=null, router_rule=null, redirect_to_https=null, https=null, path_prefix=null, redirect_to_path_prefix=null) =
local effective_https = if https != null then https else _docker_reverse_proxy_https;
{
    "traefik.enable": "true",
    ["traefik.http.routers." + ServiceName(name) + ".service"]: ServiceName(name),
    [if effective_https == true then "traefik.http.routers." + ServiceName(name) + "-tls.service"]: ServiceName(name),
    [if effective_https == true then "traefik.http.routers." + ServiceName(name) + "-tls.tls"]: "true",
    ["traefik.http.services." + ServiceName(name) + ".loadbalancer.server.port"]: port
}
+ (if effective_https == true then TraefikCertLabels(hostname, ServiceName(name), certresolver) else {})
+ TraefikRoutersRuleLabels(hostname, ServiceName(name), router_rule, https)
+ TraefikPathPrefixLabels(hostname, ServiceName(name), path_prefix, https)
+ TraefikPathPrefixRedirectLabels(hostname, ServiceName(name), path_prefix, redirect_to_path_prefix, https)
+ TraefikRedirectToHttpsLabels(hostname, ServiceName(name), redirect_to_https);

local TraefikVirtualHost(port, hostname, name=null, network_id=_docker_reverse_proxy_network_id, certresolver=null, router_rule=null, redirect_to_https=null, https=null, path_prefix=null, redirect_to_path_prefix=null) =
  local vh = {
    labels +: TraefikLabels(port, hostname, name, certresolver, router_rule, redirect_to_https, https, path_prefix, redirect_to_path_prefix),
    networks +: [
        "default",
        network_id
    ]
  };

  vh + {networks: std.uniq(vh.networks)};

local NoVirtualHost(port, hostname, name=null, network_id=_docker_reverse_proxy_network_id, certresolver=null, router_rule=null, redirect_to_https=null, https=null, path_prefix=null, redirect_to_path_prefix=null) = {};

local VirtualHost = if _docker_reverse_proxy_type == "traefik" then TraefikVirtualHost else NoVirtualHost;

// XDebug 3 configuration has changed.
// Default TCP port has changed from 9000 to 9003, but we still configure it to 9000 to avoid confusion while configuring code editors.
local NoXDebug(version=null, session=_core_project_name, mode="debug") = {};
local XDebug(version=null, session=_core_project_name, mode="debug") =
local xdebug2_config = ["remote_enable=" + if mode != "off" then "on" else "off", "remote_autostart=off", "idekey=" + session, "remote_host=" + _docker_debug_host];
local xdebug3_config = ["client_host=" + _docker_debug_host, "client_port=9000"];
{
    environment: {
        [if version == null || version == 2 then "PHP_IDE_CONFIG"]: "serverName=" + session,
        [if version == null || version == 3 then "XDEBUG_MODE"]: mode,
        [if version == null || version == 3 then "XDEBUG_SESSION"]: session,
        [if version == 2 then "XDEBUG_CONFIG"]: std.join(' ', xdebug2_config),
        [if version == 3 then "XDEBUG_CONFIG"]: std.join(' ', xdebug3_config),
        [if version == null then "XDEBUG_CONFIG"]: std.join(' ', (xdebug2_config + xdebug3_config))
    }
};

local envIndex(env=_core_env_current) =
    local indexes = std.find(env, _core_env_available);
    local index = if std.length(indexes) > 0 then indexes[0] else null;
    index;

local envIs(env) =
    env == _core_env_current;

{
    Image: Image,
    Build: Build,
    VirtualHost: if _docker_jsonnet_virtualhost_disabled then NoVirtualHost else VirtualHost,
    TraefikLabels: if _docker_jsonnet_virtualhost_disabled then NoTraefikLabels else TraefikLabels,
    TraefikCertLabels: if _docker_jsonnet_virtualhost_disabled then NoTraefikCertLabels else TraefikCertLabels,
    ServiceName: ServiceName,
    Binary: if _docker_jsonnet_binary_disabled then NoBinary else Binary,
    BinaryLabels: if _docker_jsonnet_binary_disabled then NoBinaryLabels else BinaryLabels,
    BinaryOptions: if _docker_jsonnet_binary_disabled then NoBinaryOptions else BinaryOptions,
    BinaryOptionsLabels: if _docker_jsonnet_binary_disabled then NoBinaryOptionsLabels else BinaryOptionsLabels,
    XDebug: if _docker_debug_disabled then NoXDebug else XDebug,
    Compose: Compose,
    Volumes: Volumes,
    Expose: Expose,
    User: User,
    userNameToUid: userNameToUid,
    groupNameToGid: groupNameToGid,
    env: {
      index: envIndex,
      is: envIs
    },
    path: path,
    JoinObjectArray: JoinObjectArray,
}